<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KB Serve - Iteration View</title>
    <style>
        /* Catppuccin Mocha palette */
        :root {
            --base: #1e1e2e;
            --mantle: #181825;
            --crust: #11111b;
            --surface0: #313244;
            --surface1: #45475a;
            --surface2: #585b70;
            --overlay0: #6c7086;
            --overlay1: #7f849c;
            --text: #cdd6f4;
            --subtext1: #bac2de;
            --subtext0: #a6adc8;
            --lavender: #b4befe;
            --blue: #89b4fa;
            --sapphire: #74c7ec;
            --sky: #89dceb;
            --teal: #94e2d5;
            --green: #a6e3a1;
            --yellow: #f9e2af;
            --peach: #fab387;
            --maroon: #eba0ac;
            --red: #f38ba8;
            --mauve: #cba6f7;
            --pink: #f5c2e7;
            --flamingo: #f2cdcd;
            --rosewater: #f5e0dc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--crust);
            color: var(--text);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }

        /* Tmux-style layout */
        .tmux-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: 1fr auto;
            height: 100vh;
            gap: 1px;
            background: var(--surface1);
        }

        .pane {
            background: var(--base);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .pane-header {
            background: var(--mantle);
            padding: 8px 16px;
            font-size: 11px;
            color: var(--subtext0);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--surface0);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pane-header .pane-index {
            color: var(--mauve);
        }

        .pane-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        /* Entity list items */
        .entity-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--surface0);
            cursor: pointer;
            transition: background 0.1s;
        }

        .entity-item:hover {
            background: var(--mantle);
        }

        .entity-item.selected {
            background: var(--surface0);
            border-left: 3px solid var(--sapphire);
        }

        .entity-title {
            font-size: 12px;
            color: var(--text);
            font-weight: 600;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .entity-meta {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 11px;
            color: var(--overlay0);
        }

        .entity-score {
            font-weight: 600;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .entity-score.high { background: var(--green); color: var(--crust); }
        .entity-score.mid { background: var(--yellow); color: var(--crust); }
        .entity-score.low { background: var(--red); color: var(--crust); }
        .entity-score.none { background: var(--surface1); color: var(--overlay0); }

        .entity-rounds {
            color: var(--overlay0);
            font-size: 10px;
        }

        .entity-status {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
        }

        .entity-status.staged { background: var(--mauve); color: var(--crust); }
        .entity-status.draft { background: var(--surface1); color: var(--overlay0); }
        .entity-status.iterating { background: var(--yellow); color: var(--crust); }
        .entity-status.ready { background: var(--green); color: var(--crust); }
        .entity-status.generating { background: var(--peach); color: var(--crust); }

        .entity-decimal {
            color: var(--mauve);
            font-size: 10px;
        }

        /* Platform badges */
        .platform-badge {
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
        }

        .platform-badge.linkedin { background: var(--blue); color: var(--crust); }
        .platform-badge.skool { background: var(--green); color: var(--crust); }

        /* Right pane - Iteration view */
        .preview-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--overlay0);
            text-align: center;
            padding: 40px;
        }

        .preview-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .iteration-view {
            padding: 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .iteration-header {
            margin-bottom: 16px;
        }

        .iteration-title {
            color: var(--sapphire);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .iteration-subtitle {
            color: var(--overlay0);
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Round navigator */
        .round-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding: 8px 12px;
            background: var(--mantle);
            border-radius: 6px;
        }

        .round-nav-label {
            color: var(--subtext0);
            font-size: 11px;
            font-weight: 600;
        }

        .round-tabs {
            display: flex;
            gap: 4px;
        }

        .round-tab {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            background: var(--surface0);
            color: var(--overlay0);
            border: none;
            font-family: inherit;
            transition: all 0.1s;
        }

        .round-tab:hover { background: var(--surface1); color: var(--text); }
        .round-tab.active { background: var(--sapphire); color: var(--crust); font-weight: 600; }

        .round-nav-hint {
            color: var(--overlay0);
            font-size: 10px;
            margin-left: auto;
        }

        .round-nav-hint .key-hint {
            background: var(--surface0);
            color: var(--sapphire);
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: 600;
        }

        /* Scores section */
        .scores-section {
            margin-bottom: 16px;
        }

        .scores-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .scores-title {
            color: var(--overlay0);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .overall-score {
            font-size: 16px;
            font-weight: 700;
        }

        .overall-score.high { color: var(--green); }
        .overall-score.mid { color: var(--yellow); }
        .overall-score.low { color: var(--red); }

        .scores-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: var(--mantle);
            border-radius: 4px;
            font-size: 11px;
        }

        .score-label {
            color: var(--subtext0);
        }

        .score-value {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .score-value.high { color: var(--green); }
        .score-value.mid { color: var(--yellow); }
        .score-value.low { color: var(--red); }

        .delta-badge {
            font-size: 9px;
            font-weight: 600;
            padding: 1px 4px;
            border-radius: 2px;
        }

        .delta-badge.up { background: rgba(166, 227, 161, 0.2); color: var(--green); }
        .delta-badge.down { background: rgba(243, 139, 168, 0.2); color: var(--red); }
        .delta-badge.same { background: rgba(108, 112, 134, 0.15); color: var(--overlay0); }

        .not-judged {
            padding: 12px;
            background: var(--mantle);
            border-radius: 6px;
            color: var(--overlay0);
            font-size: 12px;
            text-align: center;
            font-style: italic;
        }

        /* Post content */
        .post-section {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .post-section-title {
            color: var(--overlay0);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .post-text {
            flex: 1;
            background: var(--mantle);
            padding: 16px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.7;
            color: var(--text);
            overflow-y: auto;
            white-space: pre-wrap;
        }

        /* Actions bar */
        .actions-bar {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 11px;
            font-family: inherit;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.1s;
        }

        .btn-primary {
            background: var(--green);
            color: var(--crust);
            font-weight: 600;
        }

        .btn-primary:hover { background: var(--teal); }

        .btn-secondary {
            background: var(--surface0);
            color: var(--text);
        }

        .btn-secondary:hover { background: var(--surface1); }

        .btn-iterate {
            background: var(--mauve);
            color: var(--crust);
            font-weight: 600;
        }

        .btn-iterate:hover { background: var(--lavender); }

        .btn .key {
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Iterating spinner overlay */
        .iterating-overlay {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--yellow);
            color: var(--crust);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        /* Spinner animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--crust);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        /* Status bar */
        .status-bar {
            grid-column: 1 / -1;
            background: var(--sapphire);
            color: var(--crust);
            padding: 4px 16px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            font-weight: 500;
        }

        .status-section {
            display: flex;
            gap: 24px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-key {
            background: rgba(0,0,0,0.2);
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface0);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid var(--surface1);
            z-index: 1000;
        }

        .toast.show {
            display: flex;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .toast-icon {
            color: var(--green);
            font-size: 16px;
        }

        /* Empty state */
        .empty-state {
            padding: 60px 20px;
            text-align: center;
            color: var(--overlay0);
        }

        .empty-state-icon {
            font-size: 40px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 13px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--mantle); }
        ::-webkit-scrollbar-thumb { background: var(--surface1); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--surface2); }

        /* Shortcut hints */
        .shortcut-bar {
            background: var(--mantle);
            padding: 8px 16px;
            font-size: 11px;
            color: var(--subtext0);
            display: flex;
            gap: 16px;
            border-top: 1px solid var(--surface0);
            flex-wrap: wrap;
        }

        .shortcut {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .key-hint {
            background: var(--surface0);
            color: var(--sapphire);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        /* Mode toggle */
        .mode-toggle {
            display: flex;
            gap: 4px;
            background: var(--surface0);
            padding: 2px;
            border-radius: 4px;
        }

        .mode-btn {
            padding: 4px 8px;
            font-size: 11px;
            border: none;
            background: transparent;
            color: var(--overlay0);
            cursor: pointer;
            border-radius: 2px;
            font-family: inherit;
            text-decoration: none;
            display: flex;
            align-items: center;
        }

        .mode-btn.active {
            background: var(--sapphire);
            color: var(--crust);
        }

        .mode-btn:hover:not(.active) { color: var(--text); }

        .mode-btn .key-hint {
            background: rgba(0,0,0,0.2);
        }

        /* Section header */
        .section-header {
            background: var(--mantle);
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--surface0);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .section-title {
            color: var(--text);
            font-weight: 600;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-count {
            background: var(--sapphire);
            color: var(--crust);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Overall delta in header */
        .overall-delta {
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }
        .overall-delta.up { color: var(--green); }
        .overall-delta.down { color: var(--red); }
        .overall-delta.same { color: var(--overlay0); }

        /* Staging area textarea */
        .staging-textarea {
            flex: 1;
            background: var(--mantle);
            padding: 16px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.7;
            color: var(--text);
            border: 1px solid var(--surface0);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            resize: none;
            min-height: 200px;
            outline: none;
            transition: border-color 0.2s;
        }

        .staging-textarea:focus {
            border-color: var(--sapphire);
        }

        .staging-textarea.modified {
            border-color: var(--yellow);
        }

        /* Visual status indicators */
        .visual-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .visual-status.generating {
            background: var(--peach);
            color: var(--crust);
        }

        .visual-status.ready {
            background: rgba(166, 227, 161, 0.15);
            color: var(--green);
            border: 1px solid rgba(166, 227, 161, 0.3);
        }

        .visual-status.failed {
            background: rgba(243, 139, 168, 0.15);
            color: var(--red);
            border: 1px solid rgba(243, 139, 168, 0.3);
        }

        .visual-status.text_only {
            background: rgba(137, 180, 250, 0.15);
            color: var(--blue);
            border: 1px solid rgba(137, 180, 250, 0.3);
        }

        .visual-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid var(--surface0);
        }

        /* Edit info bar */
        .edit-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: var(--overlay0);
            margin-bottom: 4px;
        }

        .edit-badge {
            font-size: 10px;
            padding: 1px 6px;
            border-radius: 3px;
            background: var(--surface0);
            color: var(--subtext0);
        }

        /* Generate visuals button */
        .btn-generate {
            background: var(--peach);
            color: var(--crust);
            font-weight: 600;
        }

        .btn-generate:hover { background: var(--yellow); }

        /* Publish button */
        .btn-publish {
            background: var(--green);
            color: var(--crust);
            font-weight: 600;
        }

        .btn-publish:hover { background: var(--teal); }

        /* Save button */
        .btn-save {
            background: var(--sapphire);
            color: var(--crust);
            font-weight: 600;
        }

        .btn-save:hover { background: var(--blue); }
    </style>
</head>
<body>
    <div class="tmux-container">
        <!-- Left Pane: Entity List -->
        <div class="pane">
            <div class="pane-header">
                <span><span class="pane-index">0:</span> iterations</span>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div class="mode-toggle">
                        <a href="/" class="mode-btn"><span class="key-hint">q</span></a>
                        <button class="mode-btn active"><span class="key-hint">r</span></button>
                        <a href="/browse" class="mode-btn"><span class="key-hint">b</span></a>
                        <a href="/videos" class="mode-btn"><span class="key-hint">v</span></a>
                        <a href="/prompts" class="mode-btn"><span class="key-hint">p</span></a>
                    </div>
                    <span id="connection-status" style="color: var(--green);">connected</span>
                </div>
            </div>

            <div class="pane-body" id="entity-list">
                <!-- Populated by JavaScript -->
            </div>
            <div class="shortcut-bar" id="shortcut-bar">
                <span class="shortcut"><span class="key-hint">j/k</span> entities</span>
                <span class="shortcut"><span class="key-hint">Up/Dn</span> rounds</span>
                <span class="shortcut"><span class="key-hint">i</span> iterate</span>
                <span class="shortcut"><span class="key-hint">a</span> stage</span>
                <span class="shortcut"><span class="key-hint">c</span> copy</span>
                <span class="shortcut"><span class="key-hint">g</span> generate</span>
                <span class="shortcut"><span class="key-hint">s</span> save</span>
            </div>
        </div>

        <!-- Right Pane: Iteration Detail -->
        <div class="pane">
            <div class="pane-header">
                <span><span class="pane-index">1:</span> detail</span>
                <span id="preview-type-label" style="color: var(--sapphire);"></span>
            </div>
            <div class="pane-body" id="preview-pane">
                <div class="preview-empty">
                    <div class="preview-empty-icon">&#x1F504;</div>
                    <div>Select an entity to view iterations</div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-section">
                <span>[kb-serve]</span>
                <span id="status-count">0 entities</span>
            </div>
            <div class="status-section">
                <span class="status-item"><span class="status-key">q</span> queue</span>
                <span class="status-item"><span class="status-key">r</span> runway</span>
                <span class="status-item"><span class="status-key">b</span> browse</span>
                <span class="status-item"><span class="status-key">v</span> videos</span>
                <span class="status-item"><span class="status-key">p</span> prompts</span>
                <span id="status-host">localhost:8765</span>
            </div>
        </div>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast">
        <span class="toast-icon">+</span>
        <span id="toast-message">Copied to clipboard!</span>
    </div>

    <script>
        // State
        let queueData = { items: [], total: 0 };
        let selectedEntityIndex = 0;
        let selectedEntity = null;
        let iterationsData = null;  // from /api/action/<id>/iterations
        let selectedRoundIndex = -1; // which round is active in the detail pane

        // XSS protection helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        const PLATFORM_CLASS = {
            'LinkedIn': 'linkedin',
            'Skool': 'skool',
        };

        // Score class helper
        function scoreClass(score) {
            if (score === null || score === undefined) return 'none';
            if (score >= 4) return 'high';
            if (score >= 3) return 'mid';
            return 'low';
        }

        // Format criterion name
        function formatCriterion(name) {
            return name.replace(/_/g, ' ');
        }

        // Delta text helper
        function deltaText(prev, curr) {
            if (prev === null || prev === undefined || curr === null || curr === undefined) return '';
            const diff = curr - prev;
            if (diff > 0) return `<span class="delta-badge up">+${diff}</span>`;
            if (diff < 0) return `<span class="delta-badge down">${diff}</span>`;
            return `<span class="delta-badge same">=</span>`;
        }

        // Overall delta text
        function overallDelta(prev, curr) {
            if (prev === null || prev === undefined) return '';
            const diff = (curr - prev).toFixed(1);
            if (diff > 0) return `<span class="overall-delta up">+${diff}</span>`;
            if (diff < 0) return `<span class="overall-delta down">${diff}</span>`;
            return `<span class="overall-delta same">=</span>`;
        }

        // Fetch entity list
        async function fetchQueue() {
            try {
                const response = await fetch('/api/posting-queue-v2');
                queueData = await response.json();
                renderEntityList();
                updateStatusBar();

                // Auto-select first item if none selected
                if (selectedEntity === null && queueData.items.length > 0) {
                    selectEntity(0);
                }

                // If an entity is selected and iterating, refresh iterations
                if (selectedEntity && selectedEntity.iterating) {
                    await fetchIterations(selectedEntity.id);
                }
            } catch (error) {
                console.error('Failed to fetch queue:', error);
                document.getElementById('connection-status').innerHTML = 'disconnected';
                document.getElementById('connection-status').style.color = 'var(--red)';
            }
        }

        // Render entity list
        function renderEntityList() {
            const list = document.getElementById('entity-list');
            list.innerHTML = '';

            if (queueData.items.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">&#x1F4DD;</div>
                        <div class="empty-state-text">No items to review.<br>Run <code>kb analyze -t linkedin_v2</code> to generate content.</div>
                    </div>
                `;
                return;
            }

            // Section header
            const header = document.createElement('div');
            header.className = 'section-header';
            header.innerHTML = `
                <div class="section-title">
                    <span>Iterations</span>
                    <span class="section-count">${queueData.total}</span>
                </div>
            `;
            list.appendChild(header);

            queueData.items.forEach((item, index) => {
                const el = document.createElement('div');
                el.className = 'entity-item';
                if (index === selectedEntityIndex) el.classList.add('selected');

                const platformClass = PLATFORM_CLASS[item.destination] || '';
                const sc = scoreClass(item.latest_score);
                const scoreHtml = item.latest_score !== null
                    ? `<span class="entity-score ${sc}">${item.latest_score.toFixed(1)}</span>`
                    : `<span class="entity-score none">--</span>`;

                let statusHtml = '';
                if (item.iterating) {
                    statusHtml = '<span class="entity-status iterating"><span class="spinner" style="width:8px;height:8px;border-width:1.5px;"></span> iterating</span>';
                } else if (item.status === 'ready') {
                    statusHtml = '<span class="entity-status ready">ready</span>';
                } else if (item.visual_status === 'generating') {
                    statusHtml = '<span class="entity-status generating"><span class="spinner" style="width:8px;height:8px;border-width:1.5px;"></span> generating</span>';
                } else if (item.status === 'staged') {
                    statusHtml = '<span class="entity-status staged">staged</span>';
                } else if (item.status === 'draft') {
                    statusHtml = '<span class="entity-status draft">draft</span>';
                }

                const roundsText = item.iteration_count > 0
                    ? `${item.iteration_count} round${item.iteration_count > 1 ? 's' : ''}`
                    : '';

                el.innerHTML = `
                    <div class="entity-title">${escapeHtml(item.source_title)}</div>
                    <div class="entity-meta">
                        ${scoreHtml}
                        <span class="entity-rounds">${roundsText}</span>
                        ${statusHtml}
                        <span class="entity-decimal">${escapeHtml(item.source_decimal)}</span>
                        <span class="platform-badge ${platformClass}" style="margin-left:auto;">${escapeHtml(item.destination)}</span>
                    </div>
                `;

                el.addEventListener('click', () => selectEntity(index));
                list.appendChild(el);
            });
        }

        // Select an entity
        async function selectEntity(index) {
            if (index < 0 || index >= queueData.items.length) return;

            selectedEntityIndex = index;
            selectedEntity = queueData.items[index];

            // Update UI
            document.querySelectorAll('.entity-item').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
                if (i === index) {
                    el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            });

            document.getElementById('preview-type-label').textContent = selectedEntity.type;

            // Show staging view for staged/ready items, iteration view for others
            if (selectedEntity.status === 'staged' || selectedEntity.status === 'ready') {
                await fetchIterations(selectedEntity.id);
                renderStagingView();
            } else {
                await fetchIterations(selectedEntity.id);
            }
        }

        // Fetch iterations for selected entity
        async function fetchIterations(actionId) {
            try {
                const response = await fetch(`/api/action/${actionId}/iterations`);
                iterationsData = await response.json();

                // Default to latest round
                if (iterationsData.iterations.length > 0) {
                    selectedRoundIndex = iterationsData.iterations.length - 1;
                } else {
                    selectedRoundIndex = -1;
                }

                renderIterationView();
            } catch (error) {
                console.error('Failed to fetch iterations:', error);
                document.getElementById('preview-pane').innerHTML = `
                    <div class="preview-empty">
                        <div class="preview-empty-icon">&#x26A0;</div>
                        <div>Failed to load iterations</div>
                    </div>
                `;
            }
        }

        // Render the iteration detail view
        function renderIterationView() {
            const pane = document.getElementById('preview-pane');

            if (!iterationsData || iterationsData.iterations.length === 0) {
                pane.innerHTML = `
                    <div class="preview-empty">
                        <div class="preview-empty-icon">&#x1F4DD;</div>
                        <div>No iterations yet</div>
                    </div>
                `;
                return;
            }

            const iterations = iterationsData.iterations;
            const current = iterations[selectedRoundIndex] || iterations[iterations.length - 1];
            const prevRound = selectedRoundIndex > 0 ? iterations[selectedRoundIndex - 1] : null;

            // Build round tabs
            let roundTabsHtml = '';
            iterations.forEach((iter, i) => {
                const active = i === selectedRoundIndex ? ' active' : '';
                const sc = iter.scores ? scoreClass(iter.scores.overall) : 'none';
                const label = iter.scores
                    ? `R${iter.round} (${iter.scores.overall.toFixed(1)})`
                    : `R${iter.round}`;
                roundTabsHtml += `<button class="round-tab${active}" data-round="${i}">${label}</button>`;
            });

            // Build scores section
            let scoresHtml = '';
            if (current.scores) {
                const sc = scoreClass(current.scores.overall);
                const prevScores = prevRound && prevRound.scores ? prevRound.scores : null;

                let overallDeltaHtml = prevScores
                    ? overallDelta(prevScores.overall, current.scores.overall)
                    : '';

                let criteriaHtml = '';
                for (const [criterion, score] of Object.entries(current.scores.criteria || {})) {
                    const csc = scoreClass(score);
                    const prevScore = prevScores && prevScores.criteria ? prevScores.criteria[criterion] : null;
                    const delta = prevScore !== null && prevScore !== undefined
                        ? deltaText(prevScore, score)
                        : '';

                    criteriaHtml += `
                        <div class="score-item">
                            <span class="score-label">${formatCriterion(criterion)}</span>
                            <span class="score-value ${csc}">${score}/5 ${delta}</span>
                        </div>
                    `;
                }

                scoresHtml = `
                    <div class="scores-section">
                        <div class="scores-header">
                            <span class="scores-title">Judge Scores</span>
                            <span class="overall-score ${sc}">${current.scores.overall.toFixed(1)}/5.0 ${overallDeltaHtml}</span>
                        </div>
                        <div class="scores-grid">
                            ${criteriaHtml}
                        </div>
                    </div>
                `;
            } else {
                scoresHtml = `
                    <div class="scores-section">
                        <div class="not-judged">Not judged</div>
                    </div>
                `;
            }

            // Iterating overlay
            let iteratingHtml = '';
            if (iterationsData.iterating) {
                iteratingHtml = `
                    <div class="iterating-overlay">
                        <span class="spinner"></span>
                        Iterating... generating next round
                    </div>
                `;
            }

            const isIterating = iterationsData.iterating;

            pane.innerHTML = `
                <div class="iteration-view">
                    <div class="iteration-header">
                        <div class="iteration-title">${escapeHtml(selectedEntity.source_title)}</div>
                        <div class="iteration-subtitle">
                            <span>${escapeHtml(selectedEntity.source_decimal)}</span>
                            <span class="platform-badge ${PLATFORM_CLASS[selectedEntity.destination] || ''}">${escapeHtml(selectedEntity.destination)}</span>
                            <span>~${selectedEntity.word_count} words</span>
                        </div>
                    </div>

                    ${iteratingHtml}

                    <div class="round-nav">
                        <span class="round-nav-label">Round:</span>
                        <div class="round-tabs">${roundTabsHtml}</div>
                        <span class="round-nav-hint"><span class="key-hint">Up</span>/<span class="key-hint">Dn</span></span>
                    </div>

                    ${scoresHtml}

                    <div class="post-section">
                        <div class="post-section-title">Post Content (Round ${current.round})</div>
                        <div class="post-text">${escapeHtml(current.post)}</div>
                    </div>

                    <div class="actions-bar">
                        <button class="btn btn-iterate" onclick="triggerIterate()" ${isIterating ? 'disabled' : ''}>
                            <span>${isIterating ? 'Iterating...' : 'Iterate'}</span>
                            <span class="key">i</span>
                        </button>
                        <button class="btn btn-primary" onclick="stageItem()">
                            <span>Stage</span>
                            <span class="key">a</span>
                        </button>
                        <button class="btn btn-secondary" onclick="copyContent()">
                            <span>Copy</span>
                            <span class="key">c</span>
                        </button>
                    </div>
                </div>
            `;

            // Attach round tab click handlers
            pane.querySelectorAll('.round-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    selectedRoundIndex = parseInt(tab.dataset.round);
                    renderIterationView();
                });
            });
        }

        // Trigger iteration
        async function triggerIterate() {
            if (!selectedEntity || iterationsData.iterating) return;

            try {
                const response = await fetch(`/api/action/${selectedEntity.id}/iterate`, {
                    method: 'POST',
                });
                const data = await response.json();

                if (response.ok) {
                    showToast('Iteration started...');
                    // Immediately update UI to show iterating state
                    iterationsData.iterating = true;
                    selectedEntity.iterating = true;
                    renderIterationView();
                    renderEntityList();

                    // Start polling for completion
                    pollIteration();
                } else {
                    showToast(data.error || 'Iterate failed');
                }
            } catch (error) {
                console.error('Iterate failed:', error);
                showToast('Iterate failed');
            }
        }

        // Poll for iteration completion
        async function pollIteration() {
            if (!selectedEntity) return;

            const actionId = selectedEntity.id;
            const check = async () => {
                try {
                    const response = await fetch(`/api/action/${actionId}/iterations`);
                    const data = await response.json();

                    if (!data.iterating) {
                        // Iteration complete - refresh everything
                        iterationsData = data;
                        selectedRoundIndex = data.iterations.length - 1;
                        renderIterationView();

                        // Also refresh the entity list for updated scores
                        await fetchQueue();

                        showToast('Iteration complete!');
                        return;
                    }

                    // Still iterating, poll again
                    setTimeout(check, 2000);
                } catch (error) {
                    console.error('Poll failed:', error);
                    setTimeout(check, 3000);
                }
            };

            setTimeout(check, 2000);
        }

        // Stage item
        async function stageItem() {
            if (!selectedEntity) return;

            try {
                const response = await fetch(`/api/action/${selectedEntity.id}/stage`, {
                    method: 'POST',
                });
                const data = await response.json();

                if (response.ok) {
                    showToast('Staged! Content copied to clipboard.');
                    await fetchQueue();

                    // Re-select the same entity
                    if (selectedEntityIndex < queueData.items.length) {
                        selectEntity(selectedEntityIndex);
                    }
                } else {
                    showToast(data.error || 'Stage failed');
                }
            } catch (error) {
                console.error('Stage failed:', error);
                showToast('Stage failed');
            }
        }

        // Copy content
        async function copyContent() {
            if (!selectedEntity || !iterationsData) return;

            const current = iterationsData.iterations[selectedRoundIndex];
            if (!current) return;

            // For staged/ready items, copy from textarea if visible
            const textarea = document.getElementById('staging-editor');
            const textToCopy = textarea ? textarea.value : current.post;

            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast('Copied to clipboard!');
            } catch (error) {
                // Fallback to server-side
                try {
                    await fetch(`/api/action/${selectedEntity.id}/copy`, { method: 'POST' });
                    showToast('Copied to clipboard!');
                } catch (err) {
                    console.error('Copy failed:', err);
                    showToast('Copy failed');
                }
            }
        }

        // Track if text has been modified in staging
        let textModified = false;
        let originalText = '';

        // Render the staging view (for staged/ready items)
        function renderStagingView() {
            const pane = document.getElementById('preview-pane');

            if (!selectedEntity || !iterationsData) return;

            const iterations = iterationsData.iterations;
            const latestRound = iterations.length > 0 ? iterations[iterations.length - 1] : null;
            const postText = selectedEntity.content || (latestRound ? latestRound.post : '');
            originalText = postText;
            textModified = false;

            const status = selectedEntity.status;
            const visualStatus = selectedEntity.visual_status || '';
            const editCount = selectedEntity.edit_count || 0;
            const stagedRound = selectedEntity.staged_round || 0;

            // Visual status indicator
            let visualStatusHtml = '';
            if (visualStatus === 'generating') {
                visualStatusHtml = `
                    <div class="visual-status generating">
                        <span class="spinner"></span>
                        Generating visuals...
                    </div>
                `;
            } else if (visualStatus === 'ready') {
                let thumbHtml = '';
                if (selectedEntity.thumbnail_url) {
                    thumbHtml = `<img class="visual-thumbnail" src="${escapeHtml(selectedEntity.thumbnail_url)}" alt="Preview">`;
                }
                visualStatusHtml = `
                    <div class="visual-status ready">
                        ${thumbHtml}
                        <span>Visuals ready</span>
                    </div>
                `;
            } else if (visualStatus === 'failed') {
                visualStatusHtml = `
                    <div class="visual-status failed">
                        Visual generation failed
                    </div>
                `;
            } else if (visualStatus === 'text_only') {
                visualStatusHtml = `
                    <div class="visual-status text_only">
                        Text-only post (no visuals needed)
                    </div>
                `;
            }

            // Edit info
            let editInfoHtml = '';
            if (editCount > 0) {
                editInfoHtml = `
                    <div class="edit-info">
                        <span class="edit-badge">v${stagedRound}.${editCount}</span>
                        <span>${editCount} edit${editCount > 1 ? 's' : ''}</span>
                    </div>
                `;
            } else {
                editInfoHtml = `
                    <div class="edit-info">
                        <span class="edit-badge">v${stagedRound}.0 (original)</span>
                    </div>
                `;
            }

            // Determine which buttons are available
            const isReady = status === 'ready' || visualStatus === 'ready' || visualStatus === 'text_only';
            const isGenerating = visualStatus === 'generating';
            const canGenerate = status === 'staged' && !isGenerating;
            const canPublish = isReady;

            pane.innerHTML = `
                <div class="iteration-view">
                    <div class="iteration-header">
                        <div class="iteration-title">${escapeHtml(selectedEntity.source_title)}</div>
                        <div class="iteration-subtitle">
                            <span>${escapeHtml(selectedEntity.source_decimal)}</span>
                            <span class="platform-badge ${PLATFORM_CLASS[selectedEntity.destination] || ''}">${escapeHtml(selectedEntity.destination)}</span>
                            <span>~${selectedEntity.word_count} words</span>
                            <span class="entity-status ${status}">${status}</span>
                        </div>
                    </div>

                    ${visualStatusHtml}

                    <div class="post-section">
                        <div class="post-section-title">
                            Edit Post
                            ${editInfoHtml}
                        </div>
                        <textarea id="staging-editor" class="staging-textarea">${escapeHtml(postText)}</textarea>
                    </div>

                    <div class="actions-bar">
                        <button class="btn btn-save" id="btn-save" onclick="saveEdit()" disabled>
                            <span>Save</span>
                            <span class="key">s</span>
                        </button>
                        <button class="btn btn-generate" onclick="generateVisuals()" ${canGenerate ? '' : 'disabled'}>
                            <span>${isGenerating ? 'Generating...' : 'Generate Visuals'}</span>
                            <span class="key">g</span>
                        </button>
                        <button class="btn btn-publish" onclick="publishItem()" ${canPublish ? '' : 'disabled'}>
                            <span>Publish</span>
                            <span class="key">p</span>
                        </button>
                        <button class="btn btn-secondary" onclick="copyContent()">
                            <span>Copy</span>
                            <span class="key">c</span>
                        </button>
                    </div>
                </div>
            `;

            // Attach textarea change tracking
            const textarea = document.getElementById('staging-editor');
            const saveBtn = document.getElementById('btn-save');
            textarea.addEventListener('input', () => {
                textModified = textarea.value !== originalText;
                textarea.classList.toggle('modified', textModified);
                saveBtn.disabled = !textModified;
            });

            // If generating, start polling for completion
            if (isGenerating) {
                pollVisualGeneration();
            }
        }

        // Save text edit
        async function saveEdit() {
            if (!selectedEntity || !textModified) return;

            const textarea = document.getElementById('staging-editor');
            if (!textarea) return;

            try {
                const response = await fetch(`/api/action/${selectedEntity.id}/save-edit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: textarea.value }),
                });
                const data = await response.json();

                if (response.ok) {
                    showToast(`Saved as edit #${data.edit_number}`);
                    textModified = false;
                    originalText = textarea.value;
                    textarea.classList.remove('modified');
                    document.getElementById('btn-save').disabled = true;

                    // Refresh queue to update edit count
                    await fetchQueue();
                    // Re-render staging view with updated edit info
                    if (selectedEntity.status === 'staged' || selectedEntity.status === 'ready') {
                        // Re-find entity in updated queue
                        const updated = queueData.items.find(i => i.id === selectedEntity.id);
                        if (updated) {
                            selectedEntity = updated;
                            renderStagingView();
                            // Restore text in case re-render reset it
                            const newTextarea = document.getElementById('staging-editor');
                            if (newTextarea) newTextarea.value = originalText;
                        }
                    }
                } else {
                    showToast(data.error || 'Save failed');
                }
            } catch (error) {
                console.error('Save failed:', error);
                showToast('Save failed');
            }
        }

        // Generate visuals
        async function generateVisuals() {
            if (!selectedEntity || selectedEntity.status !== 'staged') return;
            if (selectedEntity.visual_status === 'generating') return;

            try {
                const response = await fetch(`/api/action/${selectedEntity.id}/generate-visuals`, {
                    method: 'POST',
                });
                const data = await response.json();

                if (response.ok) {
                    showToast('Visual generation started...');
                    selectedEntity.visual_status = 'generating';
                    renderStagingView();
                    renderEntityList();
                    pollVisualGeneration();
                } else {
                    showToast(data.error || 'Generate failed');
                }
            } catch (error) {
                console.error('Generate visuals failed:', error);
                showToast('Generate visuals failed');
            }
        }

        // Poll for visual generation completion
        function pollVisualGeneration() {
            if (!selectedEntity) return;

            const actionId = selectedEntity.id;
            const check = async () => {
                try {
                    await fetchQueue();

                    // Find the entity in the updated queue
                    const updated = queueData.items.find(i => i.id === actionId);
                    if (!updated) return;

                    if (updated.visual_status !== 'generating') {
                        // Generation complete
                        selectedEntity = updated;
                        renderStagingView();
                        renderEntityList();

                        if (updated.visual_status === 'ready' || updated.visual_status === 'text_only') {
                            showToast('Visuals ready!');
                        } else if (updated.visual_status === 'failed') {
                            showToast('Visual generation failed');
                        }
                        return;
                    }

                    // Still generating, poll again
                    setTimeout(check, 2000);
                } catch (error) {
                    console.error('Visual poll failed:', error);
                    setTimeout(check, 3000);
                }
            };

            setTimeout(check, 2000);
        }

        // Publish / mark as posted
        async function publishItem() {
            if (!selectedEntity) return;

            const status = selectedEntity.status;
            const vs = selectedEntity.visual_status || '';
            const canPublish = status === 'ready' || vs === 'ready' || vs === 'text_only';
            if (!canPublish) {
                showToast('Item must be ready before publishing');
                return;
            }

            // Copy to clipboard first
            const textarea = document.getElementById('staging-editor');
            const textToCopy = textarea ? textarea.value : selectedEntity.content;
            try {
                await navigator.clipboard.writeText(textToCopy);
            } catch (e) {
                // fallback
                try { await fetch(`/api/action/${selectedEntity.id}/copy`, { method: 'POST' }); } catch (err) {}
            }

            try {
                const response = await fetch(`/api/action/${selectedEntity.id}/posted`, {
                    method: 'POST',
                });
                const data = await response.json();

                if (response.ok) {
                    showToast('Published! Content copied to clipboard.');
                    await fetchQueue();
                    // Select next entity if available
                    if (queueData.items.length > 0) {
                        selectEntity(Math.min(selectedEntityIndex, queueData.items.length - 1));
                    }
                } else {
                    showToast(data.error || 'Publish failed');
                }
            } catch (error) {
                console.error('Publish failed:', error);
                showToast('Publish failed');
            }
        }

        // Update status bar
        function updateStatusBar() {
            document.getElementById('status-count').textContent = `${queueData.total} entities`;
        }

        // Show toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            toastMessage.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // Check if staging view is active (entity is staged/ready)
        function isStagingMode() {
            return selectedEntity && (selectedEntity.status === 'staged' || selectedEntity.status === 'ready');
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            // Skip shortcuts when typing in textarea (except Escape and Ctrl+S)
            const isInTextarea = document.activeElement && document.activeElement.tagName === 'TEXTAREA';
            if (isInTextarea) {
                // Ctrl+S / Cmd+S to save from textarea
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveEdit();
                    return;
                }
                // Escape to blur textarea
                if (e.key === 'Escape') {
                    document.activeElement.blur();
                    return;
                }
                // All other keys go to textarea
                return;
            }

            // Mode switching (always active, except 'p' which is context-dependent)
            if (e.key === 'q') {
                window.location.href = '/';
                return;
            }
            if (e.key === 'b') {
                window.location.href = '/browse';
                return;
            }
            if (e.key === 'v') {
                window.location.href = '/videos';
                return;
            }
            if (e.key === 'p') {
                // In staging mode, 'p' means publish (not navigate to prompts)
                if (isStagingMode()) {
                    publishItem();
                    return;
                }
                window.location.href = '/prompts';
                return;
            }

            if (queueData.items.length === 0) return;

            if (e.key === 'j') {
                // Move down through entities
                selectEntity(Math.min(selectedEntityIndex + 1, queueData.items.length - 1));
            } else if (e.key === 'k') {
                // Move up through entities
                selectEntity(Math.max(selectedEntityIndex - 1, 0));
            } else if (e.key === 'ArrowDown') {
                // Move to next round within entity
                e.preventDefault();
                if (iterationsData && selectedRoundIndex < iterationsData.iterations.length - 1) {
                    selectedRoundIndex++;
                    renderIterationView();
                }
            } else if (e.key === 'ArrowUp') {
                // Move to previous round within entity
                e.preventDefault();
                if (iterationsData && selectedRoundIndex > 0) {
                    selectedRoundIndex--;
                    renderIterationView();
                }
            } else if (e.key === 'i') {
                // Iterate
                triggerIterate();
            } else if (e.key === 'a') {
                // Stage (NOT approve)
                stageItem();
            } else if (e.key === 'c') {
                // Copy
                copyContent();
            } else if (e.key === 'g') {
                // Generate visuals (staging mode only)
                if (isStagingMode()) {
                    generateVisuals();
                }
            } else if (e.key === 's') {
                // Save edit (staging mode only)
                if (isStagingMode()) {
                    saveEdit();
                }
            }
        });

        // Initialize
        fetchQueue();

        // Poll for updates every 5 seconds
        setInterval(fetchQueue, 5000);
    </script>
</body>
</html>
